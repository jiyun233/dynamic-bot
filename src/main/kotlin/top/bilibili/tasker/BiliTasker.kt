package top.bilibili.tasker

import kotlinx.coroutines.*
import top.bilibili.core.BiliBiliBot
import top.bilibili.utils.logger
import kotlin.coroutines.CoroutineContext

abstract class BiliTasker(
    private val taskerName: String? = null
) : CoroutineScope, CompletableJob by SupervisorJob(BiliBiliBot.coroutineContext.job) {
    override val coroutineContext: CoroutineContext
        get() = this + CoroutineName(taskerName ?: this::class.simpleName ?: "Tasker")

    companion object {
        val taskers = mutableListOf<BiliTasker>()

        fun cancelAll() {
            taskers.forEach {
                it.cancel()
            }
        }
    }

    private var job: Job? = null

    abstract var interval: Int
    open val unitTime: Long = 1000

    protected open fun init() {}

    protected open fun before() {}
    protected abstract suspend fun main()
    protected open fun after() {}

    override fun start(): Boolean {
        job = launch(coroutineContext) {
            var consecutiveErrors = 0
            val maxErrors = 10

            // ✅ 初始化失败直接退出
            try {
                init()
            } catch (e: Exception) {
                logger.error("任务 ${this::class.simpleName} 初始化失败", e)
                return@launch
            }

            if (interval == -1) {
                // 一次性任务
                runCatching {
                    before()
                    main()
                    after()
                }.onFailure { e ->
                    logger.error("一次性任务 ${this::class.simpleName} 执行失败", e)
                }
            } else {
                // 周期性任务
                while (isActive) {
                    val result = runCatching {
                        before()
                        main()
                        after()
                    }

                    if (result.isFailure) {
                        consecutiveErrors++
                        logger.error("任务 ${this::class.simpleName} 执行失败 ($consecutiveErrors/$maxErrors)", result.exceptionOrNull())

                        // ✅ 连续失败过多则停止任务
                        if (consecutiveErrors >= maxErrors) {
                            logger.error("任务 ${this::class.simpleName} 连续失败 $maxErrors 次，停止任务")
                            break
                        }

                        // ✅ 指数退避策略
                        val backoffDelay = minOf(120000L, consecutiveErrors * 10000L)
                        delay(backoffDelay)
                    } else {
                        // ✅ 成功后重置计数器
                        consecutiveErrors = 0
                    }

                    delay(interval * unitTime)
                }
            }
            if (!isActive) logger.error("${this::class.simpleName} 已停止工作!")
        }

        return taskers.add(this)
    }

    override fun cancel(cause: CancellationException?) {
        job?.cancel(cause)
        coroutineContext.cancelChildren(cause)
        taskers.remove(this)  // ✅ P0修复: 从列表中移除，防止内存泄漏
    }
}